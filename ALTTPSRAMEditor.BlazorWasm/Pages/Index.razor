@page "/"
@inject GameService GameService
@inject TextCharacterData TextCharacterData
@inject IJSRuntime JsRuntime

<MudPaper Class="p-6 mb-6">
    <div class="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
        <div>
            <MudText Typo="Typo.h4">SRAM Editor</MudText>
            <MudText Typo="Typo.subtitle2" Color="Color.Secondary">Load an SRAM file to begin editing.</MudText>
        </div>
        <div class="relative inline-block">
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.UploadFile">
                Load SRAM
            </MudButton>
            <InputFile OnChange="HandleFileSelected" accept=".srm"
                       class="absolute inset-0 h-full w-full cursor-pointer opacity-0" />
        </div>
    </div>
    @if (!string.IsNullOrWhiteSpace(StatusMessage))
    {
        <MudAlert Severity="Severity.Info" Dense="true" Class="mt-4">@StatusMessage</MudAlert>
    }
</MudPaper>

@if (GameService.HasLoadedFile)
{
    <div class="grid grid-cols-1 gap-4 lg:grid-cols-3">
        <MudPaper Class="p-4">
            <MudText Typo="Typo.subtitle1">Current File</MudText>
            <MudRadioGroup T="int" @bind-Value="SelectedSlot" Class="mt-2">
                <MudRadio T="int" Value="1" Color="Color.Primary">File 1</MudRadio>
                <MudRadio T="int" Value="2" Color="Color.Primary">File 2</MudRadio>
                <MudRadio T="int" Value="3" Color="Color.Primary">File 3</MudRadio>
            </MudRadioGroup>
            <MudStack Spacing="1" Class="mt-4">
                <MudButton Variant="Variant.Outlined" OnClick="CreateFile">Create</MudButton>
                <MudButton Variant="Variant.Outlined" OnClick="CopyFile">Copy</MudButton>
                <MudButton Variant="Variant.Outlined" OnClick="WriteFile">Write</MudButton>
                <MudButton Variant="Variant.Outlined" Color="Color.Error" OnClick="EraseFile">Erase</MudButton>
            </MudStack>
        </MudPaper>

        <MudPaper Class="p-4">
        <MudText Typo="Typo.subtitle1">Filename</MudText>
        <div class="relative mt-2 h-12 w-48">
            <img class="pixelated h-full w-full" src="@GetResourceUrl(GetFilenamePanelImage())" alt="Filename panel" />
            <img class="pixelated absolute left-2 top-2 h-6 w-6" src="@GetResourceUrl("Player Name Heart.png")" alt="Heart" />
            <span class="absolute left-10 top-2 text-sm font-semibold tracking-widest text-white">
                @PlayerName
            </span>
        </div>
        <MudTextField @bind-Value="PlayerName" Label="Player Name" Variant="Variant.Outlined" Class="mt-3" />
        <MudStack Row="true" Spacing="1" Class="mt-3 flex-wrap">
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ApplyPlayerName">Change Name</MudButton>
            <MudButton Variant="Variant.Outlined" OnClick="ResetDeaths">Reset Deaths</MudButton>
        </MudStack>
        <MudDivider Class="my-4" />
        <MudText Typo="Typo.subtitle2" Color="Color.Secondary">Region: @CurrentRegion</MudText>
        </MudPaper>

        <MudPaper Class="p-4">
            <MudText Typo="Typo.subtitle1">Inventory</MudText>
            <div class="mt-3 grid grid-cols-5 gap-2 rounded bg-black p-3">
                @foreach (var slot in InventorySlots)
                {
                    <button type="button"
                            class="flex items-center justify-center rounded border border-slate-700 bg-slate-900 p-1 hover:border-slate-400"
                            @onclick="() => ToggleInventoryItem(slot)">
                        <img class="pixelated h-10 w-10" src="@slot.ImageSelector()" alt="@slot.Name" />
                    </button>
                }
            </div>
        </MudPaper>
    </div>

    <div class="grid grid-cols-1 gap-4 lg:grid-cols-3 mt-4">
        <MudPaper Class="p-4 lg:col-span-2">
            <MudText Typo="Typo.subtitle1">HUD</MudText>
            <div class="grid grid-cols-1 gap-3 md:grid-cols-3 mt-3">
                <MudNumericField T="int" @bind-Value="HeartContainers" Label="Heart Containers" Variant="Variant.Outlined"
                                 Min="8" Max="160" />
                <MudNumericField T="int" @bind-Value="CurrentMagic" Label="Magic" Variant="Variant.Outlined"
                                 Min="0" Max="128" />
                <MudNumericField T="int" @bind-Value="Rupees" Label="Rupees" Variant="Variant.Outlined"
                                 Min="0" Max="999" />
            </div>
            <div class="mt-3 grid grid-cols-10 gap-1">
                @for (var i = 0; i < 20; i++)
                {
                    <div class="flex items-center justify-center">
                        @if (i < DisplayHearts)
                        {
                            <img class="pixelated h-6 w-6" src="@GetResourceUrl("HeartContainerFull.png")" alt="Heart" />
                        }
                        else
                        {
                            <div class="h-6 w-6"></div>
                        }
                    </div>
                }
            </div>
            <div class="mt-2 flex items-center gap-4">
                @if (HeartPieces > 0)
                {
                    <img class="pixelated h-6 w-6" src="@GetResourceUrl(GetHeartPieceImage())" alt="Heart piece" />
                }
                <div class="relative h-[45px] w-[16px]">
                    <img class="pixelated h-full w-full" src="@GetResourceUrl(GetMagicBarImage())" alt="Magic bar outline" />
                    <div class="absolute bottom-0"
                         style="@GetMagicFillStyle()"></div>
                    @if (CurrentMagic > 0)
                    {
                        <div class="absolute"
                             style="@GetMagicHighlightStyle()"></div>
                    }
                </div>
            </div>
            <div class="grid grid-cols-1 gap-3 md:grid-cols-4 mt-3">
                <MudNumericField T="int" @bind-Value="ArrowUpgrades" Label="Arrow Upgrades" Variant="Variant.Outlined"
                                 Min="0" Max="7" />
                <MudNumericField T="int" @bind-Value="ArrowsHeld" Label="Arrows Held" Variant="Variant.Outlined"
                                 Min="0" Max="@MaxArrows" />
                <MudNumericField T="int" @bind-Value="BombUpgrades" Label="Bomb Upgrades" Variant="Variant.Outlined"
                                 Min="0" Max="7" />
                <MudNumericField T="int" @bind-Value="BombsHeld" Label="Bombs Held" Variant="Variant.Outlined"
                                 Min="0" Max="@MaxBombs" />
            </div>
            <MudStack Row="true" Spacing="1" Class="mt-4 flex-wrap">
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ApplyPlayerChanges">Apply Changes</MudButton>
                <MudButton Variant="Variant.Outlined" OnClick="CycleMagicUpgrade">Cycle Magic Upgrade (@MagicUpgrade)</MudButton>
            </MudStack>
        </MudPaper>

        <MudPaper Class="p-4">
            <MudText Typo="Typo.subtitle1">Pendants and Crystals</MudText>
            <div class="mt-3 grid gap-3">
                <div class="grid grid-cols-3 gap-2 rounded bg-black p-3">
                    @foreach (var pendant in PendantSlots)
                    {
                        <button type="button"
                                class="flex items-center justify-center rounded border border-transparent hover:border-slate-400"
                                @onclick="() => TogglePendant(pendant)">
                            <img class="pixelated h-10 w-10" src="@pendant.ImageSelector()" alt="@pendant.Name" />
                        </button>
                    }
                </div>
                <div class="grid grid-cols-4 gap-2 rounded bg-black p-3">
                    @foreach (var crystal in CrystalSlots)
                    {
                        <button type="button"
                                class="flex items-center justify-center rounded border border-transparent hover:border-slate-400"
                                @onclick="() => ToggleCrystal(crystal)">
                            <img class="pixelated h-8 w-8" src="@crystal.ImageSelector()" alt="@crystal.Name" />
                        </button>
                    }
                </div>
            </div>
        </MudPaper>
    </div>

    <MudPaper Class="p-4 mt-4 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <MudText Typo="Typo.subtitle2" Color="Color.Secondary">Ready to download updated SRAM.</MudText>
        <MudButton Variant="Variant.Filled" Color="Color.Success" StartIcon="@Icons.Material.Filled.Download" OnClick="SaveFile">
            Download Updated SRAM
        </MudButton>
    </MudPaper>
}

@code {
    private const long MaxSrmSize = 0x8000;

    private string StatusMessage { get; set; } = string.Empty;
    private SaveRegion? CurrentRegion { get; set; }
    private int _selectedSlot = 1;

    private int SelectedSlot
    {
        get => _selectedSlot;
        set
        {
            if (_selectedSlot == value)
            {
                return;
            }

            _selectedSlot = value;

            if (GameService.HasLoadedFile)
            {
                GameService.SetCurrentSlot(value);
                LoadPlayerStats();
            }
        }
    }

    private string PlayerName { get; set; } = string.Empty;
    private int Rupees { get; set; }
    private int HeartContainers { get; set; }
    private int CurrentMagic { get; set; }
    private int ArrowUpgrades { get; set; }
    private int ArrowsHeld { get; set; }
    private int BombUpgrades { get; set; }
    private int BombsHeld { get; set; }
    private int MagicUpgrade { get; set; }
    private int HeartPieces { get; set; }
    private ViewModels.CollectibleState? Collectibles { get; set; }
    private ViewModels.BottleState? Bottles { get; set; }

    private List<InventorySlot> InventorySlots { get; set; } = new();
    private List<CollectibleSlot> PendantSlots { get; set; } = new();
    private List<CollectibleSlot> CrystalSlots { get; set; } = new();

    private int MaxArrows => ItemManagementService.GetMaxArrows(ArrowUpgrades);
    private int MaxBombs => ItemManagementService.GetMaxBombs(BombUpgrades);

    private async Task HandleFileSelected(InputFileChangeEventArgs args)
    {
        var file = args.File;
        if (file is null)
        {
            return;
        }

        if (file.Size > MaxSrmSize)
        {
            StatusMessage = "Invalid SRAM File. (Randomizer saves aren't supported. Maybe one day...?)";
            return;
        }

        await using var stream = file.OpenReadStream(MaxSrmSize);
        using var memoryStream = new MemoryStream();
        await stream.CopyToAsync(memoryStream);
        var data = memoryStream.ToArray();

        var result = GameService.LoadSramData(data, TextCharacterData, file.Name);
        if (!result.success)
        {
            StatusMessage = result.message;
            return;
        }

        CurrentRegion = result.region;
        StatusMessage = result.message;
        SelectedSlot = GameService.CurrentSlot;
        LoadPlayerStats();
    }

    private void LoadPlayerStats()
    {
        var stats = GameService.GetPlayerStats();
        PlayerName = stats.PlayerName;
        Rupees = stats.Rupees;
        HeartContainers = stats.HeartContainers;
        CurrentMagic = stats.CurrentMagic;
        ArrowUpgrades = stats.ArrowUpgrades;
        ArrowsHeld = stats.ArrowsHeld;
        BombUpgrades = stats.BombUpgrades;
        BombsHeld = stats.BombsHeld;
        MagicUpgrade = stats.MagicUpgrade;
        HeartPieces = stats.HeartPieces;
        Collectibles = GameService.GetCollectibleState();
        Bottles = GameService.GetBottleState();
        BuildInventorySlots();
        BuildCollectibleSlots();
    }

    private void ApplyPlayerName()
    {
        GameService.SetPlayerName(PlayerName);
        StatusMessage = "Updated player name.";
    }

    private void ResetDeaths()
    {
        GameService.ResetDeaths(true);
        StatusMessage = "Reset deaths for the selected file.";
    }

    private void CreateFile()
    {
        var region = CurrentRegion ?? SaveRegion.USA;
        GameService.CreateFile(SelectedSlot, region, TextCharacterData);
        LoadPlayerStats();
        StatusMessage = $"Created File {SelectedSlot}.";
    }

    private void CopyFile()
    {
        var message = GameService.CopyFile(SelectedSlot, TextCharacterData);
        StatusMessage = string.IsNullOrWhiteSpace(message)
            ? $"Copied File {SelectedSlot}."
            : message;
    }

    private void WriteFile()
    {
        GameService.WriteFile(SelectedSlot, TextCharacterData);
        LoadPlayerStats();
        StatusMessage = $"Wrote to File {SelectedSlot}.";
    }

    private async Task EraseFile()
    {
        var confirm = await JsRuntime.InvokeAsync<bool>("confirm",
            $"You are about to PERMANENTLY ERASE File {SelectedSlot}! Are you sure?");
        if (!confirm)
        {
            return;
        }

        GameService.EraseFile(SelectedSlot);
        StatusMessage = $"Erased File {SelectedSlot}.";
    }

    private void ApplyPlayerChanges()
    {
        GameService.SetPlayerName(PlayerName);
        GameService.SetRupees(Rupees);
        GameService.SetHeartContainers(HeartContainers);
        GameService.SetMagic(CurrentMagic);
        GameService.SetArrowUpgrades(ArrowUpgrades);
        GameService.SetArrows(ArrowsHeld, ArrowUpgrades);
        GameService.SetBombUpgrades(BombUpgrades);
        GameService.SetBombs(BombsHeld, BombUpgrades);

        LoadPlayerStats();
        StatusMessage = "Applied player updates.";
    }

    private void CycleMagicUpgrade()
    {
        MagicUpgrade = GameService.CycleMagicUpgrade();
        StatusMessage = "Updated magic upgrade.";
    }

    private async Task SaveFile()
    {
        if (!GameService.HasLoadedFile)
        {
            StatusMessage = "Load a file first!";
            return;
        }

        var data = GameService.GetSaveData();
        var base64 = Convert.ToBase64String(data);
        var outputName = string.IsNullOrWhiteSpace(GameService.CurrentFilePath)
            ? "alttp.srm"
            : Path.GetFileName(GameService.CurrentFilePath);

        await JsRuntime.InvokeVoidAsync("alttpSramEditor.downloadFile", outputName, base64);
        StatusMessage = $"Prepared {outputName} for download.";
    }

    private int DisplayHearts => Math.Clamp(HeartContainers / 8, 0, 20);

    private void BuildInventorySlots()
    {
        InventorySlots =
        [
            new InventorySlot("Bow", () => GetBowImage(), () => CycleItem(BowAddress, 0x0, 0x1, 0x2, 0x3, 0x4)),
            new InventorySlot("Boomerang", () => GetBoomerangImage(), () => CycleItem(BoomerangAddress, 0x0, 0x1, 0x2)),
            new InventorySlot("Hookshot", () => GetBinaryItemImage(HookshotAddress, 0x1, "Hookshot.png", "D Hookshot.png"),
                () => ToggleBinaryItem(HookshotAddress, 0x1)),
            new InventorySlot("Bombs", () => GetCountItemImage(BombCountAddress, "Bomb.png", "D Bomb.png"), ToggleBombCount),
            new InventorySlot("Mushroom/Powder", () => GetMushroomPowderImage(),
                () => CycleItem(MushroomPowderAddress, 0x0, 0x1, 0x2)),
            new InventorySlot("Fire Rod", () => GetBinaryItemImage(FireRodAddress, 0x1, "Fire Rod.png", "D Fire Rod.png"),
                () => ToggleBinaryItem(FireRodAddress, 0x1)),
            new InventorySlot("Ice Rod", () => GetBinaryItemImage(IceRodAddress, 0x1, "Ice Rod.png", "D Ice Rod.png"),
                () => ToggleBinaryItem(IceRodAddress, 0x1)),
            new InventorySlot("Bombos", () => GetBinaryItemImage(BombosMedallionAddress, 0x1, "Bombos.png", "D Bombos.png"),
                () => ToggleBinaryItem(BombosMedallionAddress, 0x1)),
            new InventorySlot("Ether", () => GetBinaryItemImage(EtherMedallionAddress, 0x1, "Ether.png", "D Ether.png"),
                () => ToggleBinaryItem(EtherMedallionAddress, 0x1)),
            new InventorySlot("Quake", () => GetBinaryItemImage(QuakeMedallionAddress, 0x1, "Quake.png", "D Quake.png"),
                () => ToggleBinaryItem(QuakeMedallionAddress, 0x1)),
            new InventorySlot("Lamp", () => GetBinaryItemImage(LampAddress, 0x1, "Lamp.png", "D Lamp.png"),
                () => ToggleBinaryItem(LampAddress, 0x1)),
            new InventorySlot("Hammer", () => GetBinaryItemImage(MagicHammerAddress, 0x1, "Magic Hammer.png", "D Magic Hammer.png"),
                () => ToggleBinaryItem(MagicHammerAddress, 0x1)),
            new InventorySlot("Shovel/Flute", () => GetShovelFluteImage(),
                () => CycleItem(ShovelFluteAddress, 0x0, 0x1, 0x2, 0x3)),
            new InventorySlot("Bug Net", () => GetBinaryItemImage(BugNetAddress, 0x1, "Bug-Catching Net.png", "D Bug-Catching Net.png"),
                () => ToggleBinaryItem(BugNetAddress, 0x1)),
            new InventorySlot("Book", () => GetBinaryItemImage(BookAddress, 0x1, "Book of Mudora.png", "D Book of Mudora.png"),
                () => ToggleBinaryItem(BookAddress, 0x1)),
            new InventorySlot("Bottle", () => GetBottleImage(), ToggleBottle),
            new InventorySlot("Cane of Somaria", () => GetBinaryItemImage(CaneOfSomariaAddress, 0x1, "Cane of Somaria.png", "D Cane of Somaria.png"),
                () => ToggleBinaryItem(CaneOfSomariaAddress, 0x1)),
            new InventorySlot("Cane of Byrna", () => GetBinaryItemImage(CaneOfByrnaAddress, 0x1, "Cane of Byrna.png", "D Cane of Byrna.png"),
                () => ToggleBinaryItem(CaneOfByrnaAddress, 0x1)),
            new InventorySlot("Magic Cape", () => GetBinaryItemImage(MagicCapeAddress, 0x1, "Magic Cape.png", "D Magic Cape.png"),
                () => ToggleBinaryItem(MagicCapeAddress, 0x1)),
            new InventorySlot("Magic Mirror", () => GetBinaryItemImage(MagicMirrorAddress, 0x2, "Magic Mirror.png", "D Magic Mirror.png"),
                () => ToggleBinaryItem(MagicMirrorAddress, 0x2)),
            new InventorySlot("Gloves", () => GetGlovesImage(), () => CycleItem(GlovesAddress, 0x0, 0x1, 0x2)),
            new InventorySlot("Pegasus Boots", () => GetBinaryItemImage(PegasusBootsAddress, 0x1, "Pegasus Boots.png", "D Pegasus Boots.png"),
                GameService.TogglePegasusBoots),
            new InventorySlot("Zora's Flippers", () => GetBinaryItemImage(ZorasFlippersAddress, 0x1, "Zora's Flippers.png", "D Zora's Flippers.png"),
                GameService.ToggleZorasFlippers),
            new InventorySlot("Moon Pearl", () => GetBinaryItemImage(MoonPearlAddress, 0x1, "Moon Pearl.png", "D Moon Pearl.png"),
                () => ToggleBinaryItem(MoonPearlAddress, 0x1)),
            new InventorySlot("Sword", () => GetSwordImage(), () => CycleItem(SwordAddress, 0x0, 0x1, 0x2, 0x3, 0x4)),
            new InventorySlot("Shield", () => GetShieldImage(), () => CycleItem(ShieldAddress, 0x0, 0x1, 0x2, 0x3)),
            new InventorySlot("Armor", () => GetArmorImage(), () => CycleItem(ArmorAddress, 0x0, 0x1, 0x2))
        ];
    }

    private void BuildCollectibleSlots()
    {
        PendantSlots =
        [
            new CollectibleSlot("Pendant of Power", RedPendantAddress,
                () => GetPendantImage(RedPendantAddress, "Red Pendant.png")),
            new CollectibleSlot("Pendant of Wisdom", BluePendantAddress,
                () => GetPendantImage(BluePendantAddress, "Blue Pendant.png")),
            new CollectibleSlot("Pendant of Courage", GreenPendantAddress,
                () => GetPendantImage(GreenPendantAddress, "Green Pendant.png"))
        ];

        CrystalSlots =
        [
            new CollectibleSlot("Crystal 1", CrystalMMAddress, () => GetCrystalImage(CrystalMMAddress)),
            new CollectibleSlot("Crystal 2", CrystalPoD, () => GetCrystalImage(CrystalPoD)),
            new CollectibleSlot("Crystal 3", CrystalIPAddress, () => GetCrystalImage(CrystalIPAddress)),
            new CollectibleSlot("Crystal 4", CrystalTRAddress, () => GetCrystalImage(CrystalTRAddress)),
            new CollectibleSlot("Crystal 5", CrystalSPAddress, () => GetCrystalImage(CrystalSPAddress, true)),
            new CollectibleSlot("Crystal 6", CrystalTTAddress, () => GetCrystalImage(CrystalTTAddress, true)),
            new CollectibleSlot("Crystal 7", CrystalSWAddress, () => GetCrystalImage(CrystalSWAddress))
        ];
    }

    private string GetResourceUrl(string fileName) => $"/resources/{Uri.EscapeDataString(fileName)}";

    private string GetFilenamePanelImage() => CurrentRegion == SaveRegion.JPN
        ? "filename_JP.png"
        : "filename_USA.png";

    private string GetBowImage()
    {
        var value = GameService.GetItem(BowAddress);
        return value switch
        {
            0x1 => GetResourceUrl("Bow.png"),
            0x2 => GetResourceUrl("Bow and Arrow.png"),
            0x3 or 0x4 => GetResourceUrl("Bow and Light Arrow.png"),
            _ => GetResourceUrl("D Bow.png")
        };
    }

    private string GetBoomerangImage()
    {
        var value = GameService.GetItem(BoomerangAddress);
        return value switch
        {
            0x1 => GetResourceUrl("Boomerang.png"),
            0x2 => GetResourceUrl("Magical Boomerang.png"),
            _ => GetResourceUrl("D Boomerang.png")
        };
    }

    private string GetMushroomPowderImage()
    {
        var value = GameService.GetItem(MushroomPowderAddress);
        return value switch
        {
            0x1 => GetResourceUrl("Mushroom.png"),
            0x2 => GetResourceUrl("Magic Powder.png"),
            _ => GetResourceUrl("D Mushroom.png")
        };
    }

    private string GetShovelFluteImage()
    {
        var value = GameService.GetItem(ShovelFluteAddress);
        return value switch
        {
            0x1 => GetResourceUrl("Shovel.png"),
            0x2 or 0x3 => GetResourceUrl("Flute.png"),
            _ => GetResourceUrl("D Shovel.png")
        };
    }

    private string GetGlovesImage()
    {
        var value = GameService.GetItem(GlovesAddress);
        return value switch
        {
            0x1 => GetResourceUrl("Power Glove.png"),
            0x2 => GetResourceUrl("Titan's Mitt.png"),
            _ => GetResourceUrl("D Power Glove.png")
        };
    }

    private string GetSwordImage()
    {
        var value = GameService.GetItem(SwordAddress);
        return value switch
        {
            0x1 => GetResourceUrl("Fighter's Sword.png"),
            0x2 => GetResourceUrl("Master Sword.png"),
            0x3 => GetResourceUrl("Tempered Sword.png"),
            0x4 => GetResourceUrl("Golden Sword.png"),
            _ => GetResourceUrl("D Fighter's Sword.png")
        };
    }

    private string GetShieldImage()
    {
        var value = GameService.GetItem(ShieldAddress);
        return value switch
        {
            0x1 => GetResourceUrl("Fighter's Shield.png"),
            0x2 => GetResourceUrl("Red Shield.png"),
            0x3 => GetResourceUrl("Mirror Shield.png"),
            _ => GetResourceUrl("D Fighter's Shield.png")
        };
    }

    private string GetArmorImage()
    {
        var value = GameService.GetItem(ArmorAddress);
        return value switch
        {
            0x1 => GetResourceUrl("Blue Tunic.png"),
            0x2 => GetResourceUrl("Red Tunic.png"),
            _ => GetResourceUrl("Green Tunic.png")
        };
    }

    private string GetBottleImage()
    {
        var bottleContents = Bottles?.InventoryBottleDisplay ?? 0;
        return bottleContents > 0
            ? GetResourceUrl("Bottle.png")
            : GetResourceUrl("D Bottle.png");
    }

    private void ToggleInventoryItem(InventorySlot slot)
    {
        slot.ToggleAction?.Invoke();
        RefreshUiState();
    }

    private void TogglePendant(CollectibleSlot slot)
    {
        GameService.TogglePendant(slot.BitValue);
        RefreshUiState();
    }

    private void ToggleCrystal(CollectibleSlot slot)
    {
        GameService.ToggleCrystal(slot.BitValue);
        RefreshUiState();
    }

    private void RefreshUiState()
    {
        Collectibles = GameService.GetCollectibleState();
        Bottles = GameService.GetBottleState();
        BuildInventorySlots();
        BuildCollectibleSlots();
        StateHasChanged();
    }

    private void ToggleBinaryItem(int address, int enabledValue) =>
        GameService.ToggleItem(address, enabledValue);

    private void ToggleBombCount()
    {
        var current = GameService.GetItem(BombCountAddress);
        var next = current > 0 ? 0 : 1;
        GameService.SetItem(BombCountAddress, (byte)next);
    }

    private void ToggleBottle()
    {
        var contents = Bottles?.Bottle1Contents ?? 0;
        var next = contents > 0 ? (byte)0 : (byte)BottleContents.EMPTY;
        GameService.SetBottleContents(1, next);
    }

    private void CycleItem(int address, params int[] values)
    {
        var current = GameService.GetItem(address);
        var index = Array.IndexOf(values, current);
        var nextIndex = index < 0 ? 0 : (index + 1) % values.Length;
        GameService.SetItem(address, (byte)values[nextIndex]);
    }

    private string GetBinaryItemImage(int address, int enabledValue, string onImage, string offImage)
    {
        var value = GameService.GetItem(address);
        return value == enabledValue
            ? GetResourceUrl(onImage)
            : GetResourceUrl(offImage);
    }

    private string GetCountItemImage(int address, string onImage, string offImage)
    {
        var value = GameService.GetItem(address);
        return value > 0
            ? GetResourceUrl(onImage)
            : GetResourceUrl(offImage);
    }

    private string GetPendantImage(int pendantBit, string enabledImage) =>
        GetCollectibleImage(Collectibles?.Pendants ?? 0, pendantBit, enabledImage, "Clear Pendant.png");

    private string GetCrystalImage(int crystalBit, bool isRed = false) =>
        GetCollectibleImage(Collectibles?.Crystals ?? 0, crystalBit,
            isRed ? "Red Crystal.png" : "Blue Crystal.png",
            "Clear Crystal.png");

    private string GetCollectibleImage(byte value, int bitNumber, string enabledImage, string disabledImage)
    {
        return GetBit(value, bitNumber)
            ? GetResourceUrl(enabledImage)
            : GetResourceUrl(disabledImage);
    }

    private string GetMagicBarImage() => MagicUpgrade switch
    {
        0x1 => "lttp_magic_bar_halved.png",
        0x2 => "lttp_magic_bar_quarter.png",
        _ => "lttp_magic_bar.png"
    };

    private string GetMagicFillStyle()
    {
        var steps = GetMagicFillSteps();
        return $"left: 4px; width: 8px; height: {steps}px; bottom: 5px; background-color: #21C329;";
    }

    private string GetMagicHighlightStyle()
    {
        var steps = GetMagicFillSteps();
        return $"left: 5px; width: 6px; height: 1px; bottom: {steps + 4}px; background-color: #FFFBFF;";
    }

    private int GetMagicFillSteps()
    {
        const int maxMagic = 128;
        var clamped = Math.Clamp(CurrentMagic, 0, maxMagic);
        return (clamped + 3) / 4;
    }

    private string GetHeartPieceImage() => (HeartPieces % 4) switch
    {
        1 => "Piece of Heart Quarter.png",
        2 => "Piece of Heart Half.png",
        3 => "Piece of Heart Three Quarters.png",
        _ => "Piece of Heart Empty.png"
    };

    private static bool GetBit(byte value, int bitNumber)
    {
        bitNumber++;
        return (value & 1 << bitNumber - 1) != 0;
    }

    private record InventorySlot(string Name, Func<string> ImageSelector, Action? ToggleAction = null);

    private record CollectibleSlot(string Name, int BitValue, Func<string> ImageSelector);
}
